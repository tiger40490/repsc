Don't care about the hours taken.

-- todos:
more asserts
Q: do we need a Grid class to hold the list of mirrors and the size? It would require a Grid.h... Is it overkill?
The mirror list and the dimension need to be accessible by the movement functions.

I guess the board can be a static variable, reset before the simulation. A const pointer to it can be a field of the photon class.

In terms of header files, I hope utils.h can declare the board class in addition to the Photon and Mirror classes. 

main.cpp will need all of them.
Photon methods use the mirrors and the dimension of the board
Grid holds a list of surviving mirrors
Mirror can exist without the board.

Q: some test cases? but they take lots of cycles

Q: ttl .. just remove that one mirror from the list. Easist would be a full scan after any hit. A non-trivial effort would call directHit etc, and then clean up the list

Q: The edge scenarios

Q: how do we indicate a ray is absorbed? Set this->next to (0,0), or simply return from the call stack? Let's leave this decision to later. Not hard.
docs

<h2> Assumptions </h2>

Assumption: At any moment I (the photon) can be "affected" by at most 3 mirrors. Even though I can be "near" 8 mirrors...

Assumption: Each cell is assumed to be 1 meter by 1 meter. This simplies the discussion/documentation.
Assumption: a grid will have some mirrors, never empty.

<h2> Scenarios </h2>
Scenario T: am not on the edge, and adjacent to a mirror, perhaps with 1 or 2 diagonal mirrors. All mirrors side by side.

Scenario Y: am not on the edge, and diagonally adjacent to two symmetrical mirrors

Scenario /: am not on the edge, and diagonally adjacent to exactly one mirror 
Scenario (minor): If two adjacent edge cells both have mirrors ...

<h2> Design (... priorities ...) </h2>
At any snapshot moment, I (the photon) is in a particular cell, moving in one (of four possible) direction. 
Every surviving mirror is some distance away. 
If we compute those distances, there are only up to three mirrors within 1.42m. 
Together they decide my next Position (the cell and direction).

This free-standing function can be a method (no need to return...), can be tested independently. It requires my current cell (I will pass in a Position) and up to 3 mirrors, and also the board dimension as a global var

If I'm outside the board, then the logic is slightly different. LGpp.

A wrapper function would provide the entire survivingMirror population..

A Position type includes my current cell and a direction. Direction can be a pair.. (1,0) means increase rowId...

