See also comments in source code, not only the beginning.

<h3>My BFT algorithm after popuating the data structures</h3>
Source code explains the four global data structures + the data fields of each Cell -- chiefly Cell::uu. 
<p/>
As explained in source code, the global data structures are structurally immutable (ignore the pendingCells -- outside core algorithm) In contrast, the Cell data fields are dynamically updated by the BFT algorithm.
<p/>
I implemented a modified BFT that appends child nodes IFF current cell is concretized. It may not be obvious to everyone that this algorithm is actually correct, so I will attempt to prove it.
<p/>
The walk_tree() function starts and completes the algorithm. When walk_tree() returns, entire spreadsheet is concretized, unless cycles exist. 
<p/>
Tree nodes are spreadsheet cells, connected by directed edges.<ul>
<li>from current node, we can visit a precedent node K if K is found in the tokenArray field.
<li>from current node, we can visit a dependent node B if p2d says B is a dependent.</ul>
<p/>
Cell::evalRpn() is lenghthy but actually a minor part of the algorihm -- it mostly handles RPN evaluation and forceUpdate (experimental, optional feauture). 

Instead, bulk of the BFT logic is in walk_tree(). 
<p/>
The tree has a number of roots (i.e. "roots" global variable). The walk_tree() function starts by appending all root nodes. Rest of the algorithm is driven entirely by this queue.
<p/>
Whenever we pop a node AA, we first validate if AA has any unconcretized precedent (by following AA->uu). If yes, then we give up on AA (and AA's subtree) and don't append AA again. We are sure to visit AA again after we concretize AA's precedents.
<p/>
This "validation" has an efficiency feature. Whenever we find any node in this->uu that's now concretized, we remove it permanently from this->uu, reducing future workload. By design, this validation is guaranteed to remove some node from this->uu. Therefore, the validation on any node is never "as bad as the last validation" i.e. no progress and waste of CPU. 
<p/>
If AA passes validation, i.e. AA's precedents are all concretized. We call AA->evalRpn() with confidence. Once AA is concretized, we consult p2d to look up AA's dependents. We unconditionally append all these nodes. Then we move on to the next item in queue.
<p/>
Assuming no cycle, then evantually, every formula cell would be appended at least once and the last time it is popped it would have all its precedents already concretized.
<p/>
Q: Before we append a node X , why don't we validate X has no unconcretized precendents (early validation)?
<br/>
A: becasue at append time, X may have unconcretized precedents, but at pop-time, X may have none. Early validation is premature validation. Therefore, late validation is chosen.