See also comments in source code, not only comments at the beginning.

<h3>Here I describe the algorithm after popuating the data structures</h3>
Source code explains the four global data structures + the data fields of each Cell -- chiefly Cell::uu and Cell::concreteValue. 

As explained in source code, the global data structures are structurally immutable (except the trivial pendingCells, which can be ignored for now.) In contrast, the Cell data fields are dynamically updated by the algorithm.

I implemented a modified BFT that enqueues child nodes IFF current cell is concretized. It may not be obvious to everyone that this algorithm is actually correct, so I will attempt to prove it.

The walk_tree() function starts and completes the algorithm. When walk_tree() returns, entire spreadsheet is concretized, unless cycles exist. 

Bulk of the logic is in walk_tree(). 

Cell::evalRpn() is lenghthy but actually a minor part of the algorihm -- it mostly handles RPN evlauation and forceUpdate (experimental, optional feauture).

Below I describe the logic in walk_tree(). 

Tree nodes are spreadsheet cells, connected by directed edges. 
* from current node, we can visit a precedent node K if K is found in the tokenArray field.
* from current node, we can visit a dependent node B if p2d says B is a dependent.

The tree has a number of roots (i.e. "roots" global variable). The walk_tree() function starts by enqueuing all root nodes. Rest of the algorithm is driven entirely by this queue.

Whenever we dequeue a node AA, we first check if AA has any unconcretized precedent. If yes, then we give up on AA (and AA's subtree) and don't enqueue AA again. We are sure to visit AA again after we concretize AA's precedents.

If we do commit on AA, it means all of AA's precedents are concretized. We simply call AA->evalRpn(). Once AA is concretized, we consult p2d to look up AA's dependents. We enqueue all these nodes. Then we move on to the next item in queue.

Q: Before we enqueue a node X , why don't we check X has no unconcretized precendents (early validation)?
A: becasue at enqueue time, X may have unconcretized precedents, but at dequeue-time, X may have none. Early validation is premature validation.