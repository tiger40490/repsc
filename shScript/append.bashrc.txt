<< ______________end_of_comment_1________________
last uploaded to blog in May 2018
showcase eval $cmd
showcase "$@"
______________end_of_comment_1________________
[ -z "$(echo $- | grep i)" ] && return # this same line should be on top of append.bashrc_citi.txt
# # # # # # # # # # # # # # # # # #
#
#     << var assignment >> should be first
#
# # # # # # # # # # # # # # # # # # # # # #
git_ps1(){
  [ -d .git ] && git rev-parse --abbrev-ref HEAD 2>/dev/null
}
export PS1='\n\s!\! \u@\h [ \t \d ] \w/ $(git_ps1) \n\$ '
export EDITOR=vi # primarily for sqlplus
#export VIMINIT=":se nu | :map v :w!" # superceded by .vimrc
export EXINIT=$VIMINIT # ignored if .vimrc found!
LESS="--ignore-case"
export TMOUT=987654; [ $root ] && export TMOUT=100600
export HISTSIZE=900
export HISTTIMEFORMAT='%F %T '
set -o emacs
set +o nounset
export PATH=/usr/bin:/usr/xpg4/bin:$PATH; [ $(id -u) = 0 ] && root=yesur
set +o noclobber; [ $root ] && set -o noclobber
sav=$LOGNAME
# # # # # # # # # # # # # # # # # # # # # #
#
#            PAGER and TERM:
#
# # # # # # # # # # # # # # # # # # # # # #
export PAGER=more
export PAGERE=more
if [ -z "$(which less |grep '^no less')" ]; then
  export PAGER="less"  # breaking some x terminals but ok in "console"
  export PAGERE="less -E" # -E needed for dir-viewing, file-viewing but affects man
fi
export TERM=vt100 # vt100 is acceptable; 'linux' breaks vi in gnome-terminal;
export TERM=xterm-256color # suggested by a console color veteran. useless
export TERM=linux
# # # # # # # # # # # # # # # # # # # # # #
#
#     << aliases >> ... sortable
#
# # # # # # # # # # # # # # # # # # # # # #
alias %=cd_l # typing trainer
alias ..='cd .. ; ls1page'
alias cp='cp -i'  # defuse
alias diff='diff -W $(( $(tput cols) - 2 ))' # make use of full scren width
alias hgi="history |grep -i"
alias j1="fg %1"
alias j2="fg %2"
alias j3="fg %3"
alias killthem="perl -pe 's/^\S+(\s+\d+).*/\1/ or s/.*//'|xargs -pt kill" # p str1 | killthem
# alias m=$PAGER
alias mv='mv -i'  # defuse
alias p=ps_grep
alias path="  echo \$PATH |perl -pe 's/:/\n/g' |sort -u|$PAGERE  "
alias rm=myrm     # defuse
alias s-='  source  $HOME/.bashrc  '
alias s+='       vi $HOME/append.bashrc_ms.txt  '
alias t='l -t'
# # # # # # # # # # # # # # # # # # # # # #
#
#     << functions >> ... difficult to sort
#
# # # # # # # # # # # # # # # # # # # # # #
cvs-untrack(){
  # won't recurse into untracked sub-dir
  cvs -Q st|grep ^?
  echo
  echo -n "Comparing st vs up:  "

  # perl to remove last newline
  cvs -Q st |grep ^?|wc -l|perl -pe 'chomp if eof'
  echo -n " ^ "
  cvs -nq up|grep ^?|wc -l
}
cd_l(){
  [ $# -eq 0 ] && l && return
  [ -n "$( file $* | grep directory    )" ] && cd $* && l && return
  [ -n "$( file $* | perl -ne 'print if /text|script/' )" ] && m $* &&
/bin/echo -e "\n\n" && l $*
}
d(){
  [ $# -ne 0 ] && cd $*
  [ `pwd` = '/' ] && target=/ && echo I am in /
  echo "In MB :"
  eval du -ks * |sort -n|perl -pe 's|^(\d+)|$1/1000|e'
}
diff1(){ # remove trailing #-comments
  diff $* |perl -pe 's/\s*#.*// and chomp'
}
egi(){ # proven since 2010
  needle=` echo $1 | perl -pe 's/-/_/g' ` # replace dash
  export |grep -i $needle
}
defaultbr=master #To overwrite this variable 1) reset it after sourcing this script, 2) we could be saved in the physical directory, but not for now. 
git-rmme(){ # "removeMe", mastered in append.bashrc.txt
  # this function could be useful on the rare occasions when gd2() doesn't work.
  
  op=${1:--d} # input validation? not now
  br=$(git rev-parse --abbrev-ref HEAD)

  git checkout $defaultbr	|| return

	### "+..." immitates set-x 
  echo + git branch $op $br 
  if     git branch $op $br; then
    printf "Here are the remaining branches:\n"
  else	
    git checkout $br
  fi
  git branch
}
ls1page(){
  /bin/ls -ahlF --color=always $*
}
unalias l  2>/dev/null # in case
l(){ # can't be completely replaced by 'cd_l' or ']', because "cd_l -tr dir1" is confusing and should be avoided
 ls1page $* |$PAGERE -r # -r will interpret the --color
}
m(){ # if there's +1234 then turn on -N
  local add_opt   ## prevents previous assignment (to $add_opt) persisting

  ## m +9 file1 -> less -N +9 file1
  [[ `echo $1 |perl -ne 'print if /^\+\d+/'  ` ]] && add_opt="-N" 
  cmd="less $add_opt $@"
  [[ -n "$add_opt" ]] && printf "$cmd # starting ..\n"
  eval $cmd
  [[ -n "$add_opt" ]] && printf "$cmd # .. done\n"
}
myrm(){
  cmd="mv -i $* /var/tmp/$sav/ "
  /usr/bin/printf '%s\n'  "cmd=__$cmd __"
  eval $cmd
}
ps_grep(){
  ## cmd1='/bin/ps -ef' # truncation risk
  # ps auxwww : inconsistent for root vs non-root
  cmd1='ps auxwww' # |grep -v grep -- no cos some real commands contain grep
  for f in $*; do
    cmd1="$cmd1 | grep $f"
  done
  eval $cmd1
}
sav(){ # proven since 2007, never had a problem. You can pass in a relative or abs path :)
  suffix=$RANDOM$(date +"%H%d%b") # to avoid misleading readers,make the suffix ambiguous
  for f in $*; do
    f=$(echo $f|perl -pe 's|/$||')   # sav dir/
    b=`basename $f`
    (
      cd `dirname $f` ;
      tar cf - $b | (cd /tmp; tar xpf -)
      /bin/mv -i /tmp/$b $b.b4${sav}edit$suffix
      [ -d $f ] && opt=' -d'
      eval ls -lt $opt $b $b.b4*
    )
  done
}
# # # # # # # # # # # # # # # # # # #
#
#     << exa group of companies >> ... an exercise in grouping
#
# # # # # # # # # # # # # # # # # # # # # #
exa(){ #testing: exa -t ss ~/.ssh
# proven since 2010
  local ops
  while is_opt=`echo $1 |perl -ne 'print if /^-/'  ` && [ "$is_opt" ]; do
    ops="$ops $1"; shift
  done

  if [ $# -eq 1 ]; then
    fullpath=$1
    shortname=`echo $1|perl -pe 's|/$||;s|^.*/||'   `
  else
    fullpath=$2
    shortname=$1
  fi

  [ -x $fullpath ] || return
  eval $shortname="$fullpath" # create a shell variable with a dynamic name!
  echo -e $shortname '\t' now set to $fullpath
  prj="$fullpath"
  alias  "$shortname"="cd $fullpath;l $ops"
  alias  prj=$shortname # USE MORE
}
# # # # # # # # # # # # # # # # # # #
#
#   << path stuff, potentially dangerous >>
#
# # # # # # # # # # # # # # # # # # # # # #
add_path(){
  dir=`echo $1|perl -pe 's|/$||'`
  [ -r $dir ] || return
  echo $PATH|grep -P "$dir(:|$)" > /dev/null && return 0
  #todo: check world write perm, esp for root
  PATH=$PATH:$dir
  ret=$(echo $PATH |perl -pe 's/:/\n/g' | wc -l)
  #echo adding $dir to PATH and returning $ret
  return $ret
}
set_path(){
  add_path /usr/sbin
  add_path /usr/bin
  add_path /sbin
  add_path /usr/local/bin
  add_path /usr/cluster/bin
  add_path /usr/openwin/bin
  add_path /usr/ucb
  add_path /usr/sfw/bin  # pre-installed
  add_path /opt/csw/bin
  [ $root ] && return
  add_path .
  printf "PATH clean-up ${#PATH} -> "
  export PATH=`echo $PATH|perl -pe 's|/:|:|g' `
  printf "${#PATH}\n\n"
}
set_path
