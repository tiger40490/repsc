<pre>
See also javadoc in each class
<h3>Basic Algo</h3>
In first step, load each cell and build two data structures

* allCells -- lookup map from cell address to cell object
* p2d -- lookup map of precedent -> setOfDescendents

Once constructed, these two data structures don't change structurally, but 
there's a 3rd data structure, a queue that's enqueued and dequeued dynamically.

In the second step, we dequeue each concretized cell, look up in "p2d" to get its 
descendants. If any of the descendant can now be concretized, it is concretized 
and enqueued.

At end of the chain reaction, if the queue gets cleared, 
the entire spreadsheet is concretized. Otherwise, there exist cycles.

<h3>QnA</h3>
Q: Cell.rpn.precedents duplicates p2d data?

I feel this duplication is necessary as two-way lookup is needed -- 
value propagation vs resolving references

Cell.rpn.precedents is populated in Cell constructor. 
Subsequently, we read this field to update p2d.

This field is a readonly view of the _symbolicTokens field, which gets updated 
during concretization.

Q: is it possible to "absorb" p2d into each RPN instance?

What if we get a p2d link before constructing the precedent cell? In my unsuccessful c++ 
design, I created an empty cell just to hold the link. 

In the cleaner java design, each Cell only holds information about formula. The p2d data is 
hosted at the sheet level.

<h3>class descriptions</h3>
Cell.java and SymbolicToken.java are simple and clean abstractions. Each fits into one page :)

Simple but effective... Coherent -- each class does one job only and does it well.

Cell.java is a wrapper over a rowColId + a RPN instance.

In contrast, SpreadSheet.java and RPN.java are more complex.

SpreadSheet.java is the top-level component and the "driver". Its methods embody the 
high-level algorithm described in BasicAlgo section above. Those methods have non-trivial
hidden complexities when you look at the objects and data structures used. About half 
the complexities are in the RPN.java class.